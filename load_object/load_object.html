<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100vw; height: 100vh; display: block; }
        #debug {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            font-family: monospace;
        }
    </style>
</head>
<body onload="iniciar()">
    <canvas id="webgl-canvas"></canvas>
    <div id="debug"></div>

    <script type="x-shader/x-vertex" id="vertex-shader">#version 300 es
        in vec3 aPosition;
        in vec3 aNormal;
        in vec2 aTextureCoord;

        out vec2 vTextureCoord;
        out vec3 vNormal;

        uniform mat4 uProjectionMatrix;
        uniform mat4 uModelViewMatrix;
        uniform vec3 uScale;

        void main() {
            vec3 scaledPosition = aPosition * uScale;
            gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(scaledPosition, 1.0);
            vTextureCoord = aTextureCoord;
            vNormal = (uModelViewMatrix * vec4(aNormal, 0.0)).xyz;
        }
</script>

    <script type="x-shader/x-fragment" id="fragment-shader">#version 300 es
        precision highp float;
        
        in vec2 vTextureCoord;
        in vec3 vNormal;
        
        uniform sampler2D uSampler;
        out vec4 fragColor;
        
        void main() {
            fragColor = texture(uSampler, vTextureCoord);
        }
</script>

    <script>
        let gl;
        let programa;
        let scale = 0.5;
        let cameraZ = -3;
        let rotationX = -Math.PI / 2;
        let rotationY = 0;
        let rotationZ = 0;

        async function carregarOBJ(url) {
            const response = await fetch(url);
            const texto = await response.text();
            
            const vertices = [];
            const normais = [];
            const indices = [];
            const textureCoords = [];
            const verticesTemp = [];
            const normaisTemp = [];
            const textureCoordsTemp = [];
            
            let minVertex = [Infinity, Infinity, Infinity];
            let maxVertex = [-Infinity, -Infinity, -Infinity];

            const linhas = texto.split('\n');
            
            // document.getElementById('debug').innerHTML = `Campo para o debug...<br>`;
            
            for (let linha of linhas) {
                linha = linha.trim();
                const partes = linha.split(/\s+/);
                
                if (partes[0] === 'v') {
                    const vertex = [
                        parseFloat(partes[1] || 0),
                        parseFloat(partes[2] || 0),
                        parseFloat(partes[3] || 0)
                    ];
                    verticesTemp.push(vertex);
                    
                    // Atualizar limites
                    for (let i = 0; i < 3; i++) {
                        minVertex[i] = Math.min(minVertex[i], vertex[i]);
                        maxVertex[i] = Math.max(maxVertex[i], vertex[i]);
                    }
                }
                else if (partes[0] === 'vn') {
                    normaisTemp.push([
                        parseFloat(partes[1] || 0),
                        parseFloat(partes[2] || 0),
                        parseFloat(partes[3] || 0)
                    ]);
                }
                else if (partes[0] === 'vt') {
                    textureCoordsTemp.push([
                        parseFloat(partes[1] || 0),
                        parseFloat(partes[2] || 0),
                        // parseFloat(partes[3] || 0),
                    ]);
                }
            }

            if (normaisTemp.length === 0) {
                for (let i = 0; i < verticesTemp.length; i++) {
                    normaisTemp.push([0, 1, 0]);
                }
            }

            if (textureCoordsTemp.length === 0) {
                const rangeX = maxVertex[0] - minVertex[0];
                const rangeZ = maxVertex[2] - minVertex[2];
                
                for (let i = 0; i < verticesTemp.length; i++) {
                    const vertex = verticesTemp[i];
                    // Normalizar coordenadas entre 0 e 1
                    const u = (vertex[0] - minVertex[0]) / rangeX;
                    const v = (vertex[2] - minVertex[2]) / rangeZ;
                    textureCoordsTemp.push([u, v]);
                }
            }

            let indexVerticeAtual = 0;
            const mapVertices = new Map();

            for (let linha of linhas) {
                linha = linha.trim();
                const partes = linha.split(/\s+/);
                
                if (partes[0] === 'f') {
                    if (partes.length < 4) continue;
                    for (let i = 1; i <= 3; i++) {
                        const verticeIndices = partes[i].split('/');                        
                        let verticeIndex = parseInt(verticeIndices[0]) - 1;
                        let textureIndex = verticeIndices[1] ? parseInt(verticeIndices[1]) - 1 : -1;
                        let normalIndex = verticeIndices[2] ? parseInt(verticeIndices[2]) - 1 : -1;

                        verticeIndex = Math.max(0, Math.min(verticeIndex, verticesTemp.length - 1));
                        textureIndex = textureIndex >= 0 ? Math.min(textureIndex, textureCoordsTemp.length - 1) : verticeIndex;
                        normalIndex = normalIndex >= 0 ? Math.min(normalIndex, normaisTemp.length - 1) : verticeIndex;

                        const chave = `${verticeIndex}/${textureIndex}/${normalIndex}`;
                        
                        if (!mapVertices.has(chave)) {
                            vertices.push(...verticesTemp[verticeIndex]);
                            textureCoords.push(...textureCoordsTemp[textureIndex]);
                            normais.push(...normaisTemp[normalIndex]);
                            mapVertices.set(chave, indexVerticeAtual);
                            indices.push(indexVerticeAtual);
                            indexVerticeAtual++;
                        } else {
                            indices.push(mapVertices.get(chave));
                        }
                    }
                }
            }

            const maxDim = Math.max(
                maxVertex[0] - minVertex[0],
                maxVertex[1] - minVertex[1],
                maxVertex[2] - minVertex[2]
            );
            scale = 2.0 / maxDim;

            return {
                vertices: new Float32Array(vertices),
                normais: new Float32Array(normais),
                indices: new Uint16Array(indices),
                textureCoords: new Float32Array(textureCoords)
            };
        }

        function carregarTextura(url) {
            return new Promise((resolve) => {
                const texture = gl.createTexture();
                const image = new Image();
                image.onload = function() {
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
                    gl.generateMipmap(gl.TEXTURE_2D);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                    // Suporte a filtro anisotrópico
                    const ext = gl.getExtension("EXT_texture_filter_anisotropic") ||
                                gl.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                                gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    if (ext) {
                        const max = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                        gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, max);
                    }
                    resolve(texture);
                };
                image.src = url;
            });
        }

        async function iniciar() {
            const canvas = document.getElementById("webgl-canvas");
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            gl = canvas.getContext("webgl2");
            if (!gl) {
                alert("WebGL2 não está disponível");
                return;
            }

            gl.clearColor(1.0, 1.0, 1.0, 1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.viewport(0, 0, canvas.width, canvas.height);

            programa = criarPrograma();
            gl.useProgram(programa);

            try {
                const modeloObj = await carregarOBJ('batarang.obj');
                const textura = await carregarTextura('gray-smooth-textured-design.jpg');

                const vao = gl.createVertexArray();
                gl.bindVertexArray(vao);

                const vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, modeloObj.vertices, gl.STATIC_DRAW);
                const aPosition = gl.getAttribLocation(programa, "aPosition");
                gl.enableVertexAttribArray(aPosition);
                gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);


                const normalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, modeloObj.normais, gl.STATIC_DRAW);
                const aNormal = gl.getAttribLocation(programa, "aNormal");
                gl.enableVertexAttribArray(aNormal);
                gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);

                const textureBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, modeloObj.textureCoords, gl.STATIC_DRAW);
                const aTextureCoord = gl.getAttribLocation(programa, "aTextureCoord");
                gl.enableVertexAttribArray(aTextureCoord);
                gl.vertexAttribPointer(aTextureCoord, 2, gl.FLOAT, false, 0, 0);

                const indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, modeloObj.indices, gl.STATIC_DRAW);

                function renderizar() {
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                    const aspect = gl.canvas.width / gl.canvas.height;
                    const projectionMatrix = criarMatrizPerspectiva(45, aspect, 0.1, 100.0);
                    const modelViewMatrix = criarMatrizModelView();

                    gl.uniformMatrix4fv(
                        gl.getUniformLocation(programa, "uProjectionMatrix"),
                        false,
                        projectionMatrix
                    );
                    gl.uniformMatrix4fv(
                        gl.getUniformLocation(programa, "uModelViewMatrix"),
                        false,
                        modelViewMatrix
                    );
                    gl.uniform3f(
                        gl.getUniformLocation(programa, "uScale"),
                        scale, scale, scale
                    );

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, textura);
                    gl.uniform1i(gl.getUniformLocation(programa, "uSampler"), 0);

                    gl.bindVertexArray(vao);
                    gl.drawElements(gl.TRIANGLES, modeloObj.indices.length, gl.UNSIGNED_SHORT, 0);

                    requestAnimationFrame(renderizar);
                }

                renderizar();

                document.addEventListener('keydown', (e) => {
                    switch(e.key) {
                        case 'ArrowUp': rotationX -= 0.1; break;
                        case 'ArrowDown': rotationX += 0.1; break;
                        case 'ArrowLeft': rotationY -= 0.1; break;
                        case 'ArrowRight': rotationY += 0.1; break;
                        case 'a': rotationZ -= 0.1; break; // Rotação no eixo Z (sentido horário)
                        case 'd': rotationZ += 0.1; break; // Rotação no eixo Z (sentido anti-horário)
                        case '+': scale *= 1.1; break;
                        case '-': scale /= 1.1; break;
                        case 'w': cameraZ += 0.1; break;
                        case 's': cameraZ -= 0.1; break;
                    }
                });

            } catch (erro) {
                console.error("Erro ao carregar o modelo:", erro);
                document.getElementById('debug').innerHTML += `ERRO: ${erro.message}<br>`;
            }
        }

        function criarPrograma() {
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, document.getElementById("vertex-shader").text);
            gl.compileShader(vertexShader);

            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                console.error("Erro no vertex shader:", gl.getShaderInfoLog(vertexShader));
                return null;
            }

            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, document.getElementById("fragment-shader").text);
            gl.compileShader(fragmentShader);

            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                console.error("Erro no fragment shader:", gl.getShaderInfoLog(fragmentShader));
                return null;
            }

            const programa = gl.createProgram();
            gl.attachShader(programa, vertexShader);
            gl.attachShader(programa, fragmentShader);
            gl.linkProgram(programa);

            if (!gl.getProgramParameter(programa, gl.LINK_STATUS)) {
                console.error("Erro ao linkar programa:", gl.getProgramInfoLog(programa));
                return null;
            }

            return programa;
        }

        function criarMatrizPerspectiva(fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy * Math.PI / 360);
            const d = far - near;

            return new Float32Array([
                f/aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, -(far+near)/d, -1,
                0, 0, -2*far*near/d, 0
            ]);
        }

        function criarMatrizModelView() {
            const cosX = Math.cos(rotationX);
            const sinX = Math.sin(rotationX);
            const cosY = Math.cos(rotationY);
            const sinY = Math.sin(rotationY);
            const cosZ = Math.cos(rotationZ);
            const sinZ = Math.sin(rotationZ);

            // Matriz de rotação no eixo X
            const rotX = [
                1,    0,     0, 0,
                0,  cosX, -sinX, 0,
                0,  sinX,  cosX, 0,
                0,    0,     0, 1
            ];

            // Matriz de rotação no eixo Y
            const rotY = [
                cosY, 0, sinY, 0,
                0, 1,    0, 0,
            -sinY, 0, cosY, 0,
                0, 0,    0, 1
            ];

            // Matriz de rotação no eixo Z
            const rotZ = [
                cosZ, -sinZ, 0, 0,
                sinZ,  cosZ, 0, 0,
                0,     0, 1, 0,
                0,     0, 0, 1
            ];

            // Multiplicação das matrizes: rotX * rotY * rotZ
            const temp = new Float32Array(16);
            const modelView = new Float32Array(16);

            // Multiplica rotX * rotY e armazena em temp
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    temp[row * 4 + col] =
                        rotX[row * 4 + 0] * rotY[0 * 4 + col] +
                        rotX[row * 4 + 1] * rotY[1 * 4 + col] +
                        rotX[row * 4 + 2] * rotY[2 * 4 + col] +
                        rotX[row * 4 + 3] * rotY[3 * 4 + col];
                }
            }

            // Multiplica temp * rotZ e armazena em modelView
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    modelView[row * 4 + col] =
                        temp[row * 4 + 0] * rotZ[0 * 4 + col] +
                        temp[row * 4 + 1] * rotZ[1 * 4 + col] +
                        temp[row * 4 + 2] * rotZ[2 * 4 + col] +
                        temp[row * 4 + 3] * rotZ[3 * 4 + col];
                }
            }

            // Aplica a translação da câmera (cameraZ)
            modelView[14] = cameraZ;

            // Adiciona uma translação inicial (opcional)
            const translateX = 0; // Ajuste para mover o objeto no eixo X
            const translateY = 0; // Ajuste para mover o objeto no eixo Y
            const translateZ = 0; // Ajuste para mover o objeto no eixo Z

            modelView[12] = translateX;
            modelView[13] = translateY;
            modelView[14] += translateZ;

            return modelView;
        }
    </script>
</body>
</html>
